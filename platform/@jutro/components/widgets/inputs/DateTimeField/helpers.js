import _slicedToArray from"@babel/runtime-corejs3/helpers/slicedToArray";import isNil from"lodash/isNil";import isObject from"lodash/isObject";import isString from"lodash/isString";import{format,parse,isEqual,isAfter,isBefore}from"date-fns";import{utcToZonedTime,zonedTimeToUtc}from"date-fns-tz";import{DATA_TYPE_OBJECT}from"@jutro/prop-types";import{formatDateToDataType,parseDateFromDataType}from"@jutro/platform";function getDefaultDate(){const today=new Date;return{year:today.getFullYear(),month:today.getMonth(),day:today.getDate(),hour:0,minute:0}}function resetTime(date){return date.setHours(0),date.setMinutes(0),date.setSeconds(0),date.setMilliseconds(0),date}export function formatValueToDataType(value,options){if(!value)return;const dataType=options.dataType,includeTime=options.includeTime,timezone=options.timezone,preserveTimeZone=options.preserveTimeZone,_getDefaultDate$value={...getDefaultDate(),...value},year=_getDefaultDate$value.year,month=_getDefaultDate$value.month,day=_getDefaultDate$value.day,hour=_getDefaultDate$value.hour,minute=_getDefaultDate$value.minute;if(preserveTimeZone)return function(value,dataType){if(!isValidDate(value))return;if(dataType===DATA_TYPE_OBJECT)return value;const year=value.year,month=value.month,day=value.day,hour=value.hour,minute=value.minute,date=new Date(year,month,day,hour,minute);return`${format(date,"yyyy-MM-dd")}T${format(date,"HH:mm")}:00.000Z`}({year:year,month:month,day:day,hour:hour,minute:minute},dataType);if(timezone&&includeTime){const utcDate=zonedTimeToUtc(new Date(year,month,day,hour,minute),timezone);return dataType===DATA_TYPE_OBJECT?{year:utcDate.getUTCFullYear(),month:utcDate.getUTCMonth(),day:utcDate.getUTCDate(),hour:utcDate.getUTCHours(),minute:utcDate.getUTCMinutes()}:utcDate.toISOString()}const date=new Date(year,month,day,hour,minute);return formatDateToDataType(date,dataType,includeTime)}export function formatValueFromDataType(value,options){if(!value)return;const includeTime=options.includeTime,timezone=options.timezone;if(options.preserveTimeZone)return function(value){if(isObject(value)&&!(value instanceof Date))return value;if(isString(value)){const _value$replace$split=value.replace("Z","").split("T"),_value$replace$split2=_slicedToArray(_value$replace$split,2),datePart=_value$replace$split2[0],timePart=_value$replace$split2[1],date=parse(datePart,"yyyy-MM-dd",new Date),time=parse(timePart,"HH:mm:ss.SSS",new Date);return{year:date.getFullYear(),month:date.getMonth(),day:date.getDate(),hour:time.getHours(),minute:time.getMinutes()}}}(value);if(timezone&&includeTime){const zonedDate=utcToZonedTime(parseDateFromDataType(value,!0),timezone);return{year:zonedDate.getFullYear(),month:zonedDate.getMonth(),day:zonedDate.getDate(),hour:zonedDate.getHours(),minute:zonedDate.getMinutes()}}const date=parseDateFromDataType(value,includeTime);return Number.isNaN(Number(date.getTime()))?void 0:{year:date.getFullYear(),month:date.getMonth(),day:date.getDate(),hour:date.getHours(),minute:date.getMinutes()}}export function parseBoundaryDate(date){if(!date)return;const dateObject=parseDateFromDataType(date,!0);return format(dateObject,"yyyy-MM-dd")}export function getMinTime(minDate,value){if(!value||!minDate)return;const minDateObject=parseDateFromDataType(minDate,!0),valueDateObject=parseDateFromDataType(value,!0),minTime={hour:minDateObject.getHours(),minute:minDateObject.getMinutes()};return resetTime(minDateObject),resetTime(valueDateObject),isEqual(valueDateObject,minDateObject)?minTime:!!isBefore(valueDateObject,minDateObject)||void 0}export function getMaxTime(maxDate,value){if(!value||!maxDate)return;const maxDateObject=parseDateFromDataType(maxDate,!0),valueDateObject=parseDateFromDataType(value,!0),maxTime={hour:maxDateObject.getHours(),minute:maxDateObject.getMinutes()};return resetTime(maxDateObject),resetTime(valueDateObject),isEqual(valueDateObject,maxDateObject)?maxTime:!!isAfter(valueDateObject,maxDateObject)||void 0}export function isValidDate(value){if(!value)return!1;const year=value.year,month=value.month,day=value.day;return!isNil(year)&&!isNil(month)&&!isNil(day)}export function isValidTime(value){if(!value)return!1;const hour=value.hour,minute=value.minute;return!isNil(hour)&&!isNil(minute)}