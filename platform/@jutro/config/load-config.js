import _ from"lodash";import mustache from"mustache";const variableExpr=new RegExp("{{.+}}");function hasVariable(str){return variableExpr.test(str)}function substitute(str,params,allowMissing=!1){const tokens=mustache.parse(str,["{{","}}"]);let buffer="";return tokens.forEach((token=>{const symbol=token[0],textOrKey=token[1];switch(symbol){case"name":buffer+=function(keyMaybeValue,params,allowMissing=!1){const _splitKey=function(keyMaybeValue){const r=/([\w-.]+\s+)\|\|\s+(.*)/.exec(keyMaybeValue);return{key:r?r[1].trim():keyMaybeValue,defaultValue:r?r[2].trim().replace(/(^['"]|['"]$)/g,""):void 0}}(keyMaybeValue),key=_splitKey.key,defaultValue=_splitKey.defaultValue;let value=_.get(params,key,defaultValue);return null==value&&(allowMissing||console.warn("Error, missing key ",key," from: ",params),value=`{{${keyMaybeValue}}}`),value}(textOrKey,params,allowMissing);break;case"text":buffer+=textOrKey;break;default:throw new Error(`Parse error, unexpected symbol: ${symbol}`)}})),buffer}function concatPath(path,addPath){const str="number"==typeof addPath?`[${addPath}]`:addPath;return 0===path.length?str:"number"==typeof addPath?`${path}${str}`:`${path}.${str}`}function traverse(val,callback,path=""){_.isArray(val)?val.forEach(((elem,i)=>traverse(elem,callback,concatPath(path,i)))):_.isObject(val)?Object.keys(val).forEach((key=>traverse(val[key],callback,concatPath(path,key)))):callback(val,path)}export default function substituteParametersValues(obj,params){return traverse(obj,((val,path)=>{_.isString(val)&&hasVariable(val)&&_.set(obj,path,substitute(val,params,!0))})),traverse(obj,((val,path)=>{"string"==typeof val&&hasVariable(val)&&_.set(obj,path,substitute(val,obj))})),obj}