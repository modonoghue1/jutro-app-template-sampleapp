import _extends from"@babel/runtime-corejs3/helpers/extends";import _objectWithoutProperties from"@babel/runtime-corejs3/helpers/objectWithoutProperties";function _toPropertyKey(arg){var key=function(input,hint){if("object"!=typeof input||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!=typeof res)return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}(arg,"string");return"symbol"==typeof key?key:String(key)}import{warning,error}from"@jutro/logger";import React from"react";import PropTypes from"prop-types";import isEmpty from"lodash/isEmpty";import get from"lodash/get";import set from"lodash/set";import{wrapWithIsRequired}from"./ComponentPropTypes";import{getDisplayName}from"./getDisplayName";export const JUTRO_WARNING_PREFIX="JUTRO DEPRECATION WARNING";let warned={};export const oneOfWithDeprecations=(allowedItems,deprecatedItems,version)=>wrapWithIsRequired(((props,propName,componentName,...rest)=>{if(deprecatedItems.indexOf(props[propName])>-1){printDeprecationWarning({propName:propName,componentName:componentName,message:`Value '${props[propName]}' assigned to ${propName} is deprecated for ${componentName}. Please consider to use one of allowed values: '${allowedItems.join(", ")}' since Jutro v${version}`})}return PropTypes.oneOf([...deprecatedItems,...allowedItems])(props,propName,componentName,...rest)}));export function deprecated(validator,droppedTargetVersion="@next",additionalInfo="",...ignoredValues){return(props,propName,componentName,location,propFullName,...rest)=>{var _props$noDeprecationW;const componentNameSafe=componentName||"<<anonymous>>",propFullNameSafe=propFullName||propName,propValue=propName?props[propName]:void 0;if(propValue&&(null==ignoredValues||!ignoredValues.includes(propValue))&&(null===(_props$noDeprecationW=props.noDeprecationWarnings)||void 0===_props$noDeprecationW||!_props$noDeprecationW.includes(propName))){printDeprecationWarning({propName:propName,componentName:componentNameSafe,message:`The ${location} "${propFullNameSafe}" of "${componentNameSafe}" is deprecated. It will be removed in the "${droppedTargetVersion}" Jutro release.`,additionalInfo:additionalInfo})}return validator(props,propName,componentName,location,propFullName,...rest)}}export function deprecateAll(validators,droppedTargetVersion="@next",additionalInfo="",...ignoredValues){return Object.entries(validators).reduce(((acc,[propName,validator])=>({...acc,[propName]:deprecated(validator,droppedTargetVersion,additionalInfo,ignoredValues)})),{})}function printDeprecationWarning({propName:propName,componentName:componentName,message:message,additionalInfo:additionalInfo}){const messageKey=`${componentName}.${propName}`;warned[messageKey]||(warning(`${JUTRO_WARNING_PREFIX}: ${message} ${additionalInfo} `),warned[messageKey]=!0)}export function resetDeprecatedWarnings(component){component?Object.keys(warned).filter((key=>key.startsWith(`${component}.`))).forEach((key=>delete warned[key])):warned={}}function flattenPropsInfo(propsInfo,parentKey){return Object.entries(propsInfo).reduce(((accumulator,[key,value])=>{const type=value.type,name=value.name;let nestedProperties={};"shape"!==(null==type?void 0:type.name)&&"shape"!==name||(nestedProperties=flattenPropsInfo((null==type?void 0:type.value)||value,key));const propsKey=parentKey?`${parentKey}.${key}`:key;return{...accumulator,...nestedProperties,[propsKey]:value}}),{})}function transformProps({props:props,propsInfo:propsInfo,displayName:displayName,transformMap:transformMap,parentKey:parentKey}){return Object.entries(props).reduce(((accumulator,[key,value])=>{const propKey=parentKey?`${parentKey}.${key}`:key;if(!get(propsInfo,propKey))return warning(`The prop "${propKey}" is not defined in the PropTypes for ${displayName}`),accumulator;const _get=get(propsInfo,propKey),_get$deprecationInfo=_get.deprecationInfo,deprecationInfo=void 0===_get$deprecationInfo?{}:_get$deprecationInfo,name=_get.name,type=_get.type,mapTo=deprecationInfo.mapTo,actualName=name||(null==type?void 0:type.name);let nestedProperties={},result={...accumulator};const transform=get(transformMap,propKey),newValue=transform?transform(value):value;if(mapTo){var _newPropInfo$type;accumulator[propKey];result={..._objectWithoutProperties(accumulator,[propKey].map(_toPropertyKey))};const newPropInfo=get(propsInfo,mapTo);((null==newPropInfo?void 0:newPropInfo.name)||(null==newPropInfo||null===(_newPropInfo$type=newPropInfo.type)||void 0===_newPropInfo$type?void 0:_newPropInfo$type.name))!==actualName&&error(`The deprecated prop "${propKey}" has been mapped to the new prop "${mapTo}" but the type does not match`),set(result,mapTo,newValue)}else"shape"===actualName?nestedProperties=transformProps({props:props[key],propsInfo:propsInfo,displayName:displayName,transformMap:transformMap,parentKey:key}):set(result,propKey,newValue);return{...result,...nestedProperties}}),{})}export function transformDeprecatedProps(props,docgenInfo,transformMap={}){if(isEmpty(docgenInfo))return props;const _docgenInfo$props=docgenInfo.props,propsInfo=void 0===_docgenInfo$props?{}:_docgenInfo$props,displayName=docgenInfo.displayName;return isEmpty(propsInfo)?props:transformProps({props:props,propsInfo:flattenPropsInfo(propsInfo),displayName:displayName,transformMap:transformMap})}export const withTransformedProps=(Component,transformMap={})=>{const WithTransformedProps=props=>{const transformedProps=transformDeprecatedProps(props,null==Component?void 0:Component.__docgenInfo,transformMap);return React.createElement(Component,_extends({},props,transformedProps))};return WithTransformedProps.displayName=`withTransformedProps(${getDisplayName(Component)})`,WithTransformedProps.WrappedComponent=Component,WithTransformedProps.propTypes=Component.propTypes,WithTransformedProps};