import _classCallCheck from"@babel/runtime-corejs3/helpers/classCallCheck";import _createClass from"@babel/runtime-corejs3/helpers/createClass";import _ from"lodash";import{log}from"@jutro/logger";import Options from"./Options";let Registration=function(){function Registration(id,Service,lazy){_classCallCheck(this,Registration),this.id=id,this.name=Service.name||Service.constructor.name,this.attributes={},lazy?this.init=Service:this.service=new Service}return _createClass(Registration,[{key:"associate",value:function(attributes){this.attributes=_.merge(this.attributes,attributes)}},{key:"getMetadata",value:function(){return _.merge({id:this.id,name:this.name},this.attributes)}},{key:"isLazy",value:function(){return!!this.init}},{key:"initializeService",value:function(){if(this.init){const Service=this.init;this.service=new Service,this.init=null}else log.warning("Service is already instantiated")}},{key:"getService",value:function(){return this.isLazy()&&this.initializeService(),this.service}}]),Registration}(),ServiceRegistry=function(){function ServiceRegistry(){_classCallCheck(this,ServiceRegistry),this.registrations={},this.implementations={}}return _createClass(ServiceRegistry,[{key:"register",value:function(id,Service,options={}){if(this.registrations[id])log.warning(`Service with id '${id}' has already been registered`);else{const registration=new Registration(id,Service,options.lazy),opts=new Options(options);opts.onOption("implements",(implemented=>{(Array.isArray(implemented)?implemented:[implemented]).forEach((c=>{if(!c.implementedBy(Service))throw new Error(`Service ${Service.name||Service.constructor.name} does not implement: ${c}`);const key=c.hash();this.implementations[key]||(this.implementations[key]=[]),this.implementations[key].push(registration)}))})),opts.onOption("attributes",(attributes=>registration.associate(attributes))),this.registrations[id]=registration}}},{key:"hasRegistration",value:function(id){return!!this.registrations[id]}},{key:"getRegistration",value:function(id){return this.registrations[id]}},{key:"getRegistrationIds",value:function(){return Object.keys(this.registrations)}},{key:"getImplementorsOf",value:function(contract){const implementors=this.implementations[contract.hash()];return(!implementors||implementors.length<=0)&&log.warning(`No implementors found for: ${contract}`),implementors||[]}}]),ServiceRegistry}();export{ServiceRegistry as default};